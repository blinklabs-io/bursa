// Copyright 2025 Blink Labs Software
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package api

import (
	"context"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"log/slog"
	"net"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/blinklabs-io/bursa"
	_ "github.com/blinklabs-io/bursa/docs" // docs is generated by Swag CLI
	"github.com/blinklabs-io/bursa/gcp"
	"github.com/blinklabs-io/bursa/internal/config"
	"github.com/blinklabs-io/bursa/internal/logging"
	"github.com/go-playground/validator/v10"
	"github.com/google/uuid"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	httpSwagger "github.com/swaggo/http-swagger"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

var validate *validator.Validate

// writeJSONError writes a JSON error response safely
// nolint:unparam // statusCode currently is always a bad request in some call sites but kept for future use
func writeJSONError(
	w http.ResponseWriter,
	logger *slog.Logger,
	errorResp map[string]string,
	statusCode int,
) {
	if jsonBytes, jsonErr := json.Marshal(errorResp); jsonErr == nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(statusCode)
		_, _ = w.Write(jsonBytes)
	} else {
		logger.Error("failed to marshal error response", "error", jsonErr)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = w.Write([]byte(`{"error":"Internal server error"}`))
	}
}

// formatValidationErrors converts validator errors into a user-friendly JSON format
func formatValidationErrors(errs validator.ValidationErrors) string {
	errors := make(map[string]string)
	for _, err := range errs {
		// Convert Go field name to JSON field name
		fieldName := toJSONFieldName(err.Field())

		// Create appropriate error message based on validation tag
		switch err.Tag() {
		case "required":
			errors[fieldName] = "this field is required"
		case "min":
			// Provide more specific messages based on field and type
			switch fieldName {
			case "required":
				errors[fieldName] = "must be at least 1"
			case "key_hashes":
				errors[fieldName] = "must contain at least 1 key hash"
			default:
				kind := err.Kind()
				if kind == reflect.String {
					errors[fieldName] = "value is too short"
				} else {
					errors[fieldName] = "value is too small"
				}
			}
		case "max":
			errors[fieldName] = "value is too long or too large"
		case "oneof":
			errors[fieldName] = "must be one of: " + err.Param()
		case "hexadecimal":
			errors[fieldName] = "must be a valid hexadecimal string"
		case "len":
			errors[fieldName] = "must be exactly " + err.Param() + " characters long"
		default:
			errors[fieldName] = "invalid value"
		}
	}
	jsonBytes, err := json.Marshal(errors)
	if err != nil {
		// Fallback to a simple error message if JSON marshaling fails
		return `"marshaling failed"`
	}
	return string(jsonBytes)
}

// toJSONFieldName converts Go struct field names to their JSON equivalents
func toJSONFieldName(goFieldName string) string {
	// Common field name mappings from Go to JSON
	fieldMappings := map[string]string{
		"KeyHashes":         "key_hashes",
		"TimelockBefore":    "timelock_before",
		"TimelockAfter":     "timelock_after",
		"RequireSignatures": "require_signatures",
		"AccountId":         "account_id",
		"PaymentId":         "payment_id",
		"StakeId":           "stake_id",
		"DrepId":            "drep_id",
		"CommitteeColdId":   "committee_cold_id",
		"CommitteeHotId":    "committee_hot_id",
		"PoolColdId":        "pool_cold_id",
		"AddressId":         "address_id",
	}

	if jsonName, ok := fieldMappings[goFieldName]; ok {
		return jsonName
	}

	// Default: convert to snake_case for unmapped fields
	return toSnakeCase(goFieldName)
}

// toSnakeCase converts PascalCase to snake_case
func toSnakeCase(s string) string {
	// Convert PascalCase/UpperCamelCase to snake_case while treating
	// consecutive uppercase letters as acronyms (XMLParser -> xml_parser)
	out := []rune{}
	runes := []rune(s)
	n := len(runes)
	for i := range n {
		r := runes[i]
		// If current rune is uppercase and previous was lowercase/digit, add underscore
		if i > 0 {
			prev := runes[i-1]
			if isLower(prev) && isUpper(r) {
				out = append(out, '_')
			} else if isUpper(prev) && isUpper(r) {
				// If next rune exists and is lowercase, this marks the end of an acronym
				if i+1 < n && isLower(runes[i+1]) {
					out = append(out, '_')
				}
			}
		}
		out = append(out, r)
	}
	return strings.ToLower(string(out))
}

func isUpper(r rune) bool {
	return r >= 'A' && r <= 'Z'
}

func isLower(r rune) bool {
	return r >= 'a' && r <= 'z'
}

// mapGRPCToHTTPError maps gRPC status codes to appropriate HTTP status codes and error messages
func mapGRPCToHTTPError(w http.ResponseWriter, grpcStatus *status.Status) {
	//nolint:exhaustive // We intentionally handle unknown codes as internal server errors
	switch grpcStatus.Code() {
	case codes.NotFound:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusNotFound)
		_, _ = w.Write([]byte(`{"error":"Wallet not found"}`))
	case codes.Unauthenticated:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusUnauthorized)
		_, _ = w.Write([]byte(`{"error":"Authentication required"}`))
	case codes.PermissionDenied:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusForbidden)
		_, _ = w.Write([]byte(`{"error":"Permission denied"}`))
	case codes.Internal, codes.Unavailable, codes.Unknown:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = w.Write([]byte(`{"error":"Internal server error"}`))
	default:
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = w.Write([]byte(`{"error":"Internal server error"}`))
	}
}

// ErrorResponse defines the standard error payload returned by the API
type ErrorResponse struct {
	Error  string            `json:"error"`
	Fields map[string]string `json:"fields,omitempty"`
}

// WalletCreateRequest defines the request payload for wallet creation
type WalletCreateRequest struct {
	Password string `json:"password"`
}

// WalletDeleteRequest defines the request payload for wallet deletion
type WalletDeleteRequest struct {
	Name     string `json:"name"     validate:"required,min=1,max=100"`
	Password string `json:"password"`
}

// WalletGetRequest defines the request payload for wallet loading
type WalletGetRequest struct {
	Name     string `json:"name"     validate:"required,min=1,max=100"`
	Password string `json:"password"`
}

// WalletRestoreRequest defines the request payload for wallet restoration
type WalletRestoreRequest struct {
	Mnemonic        string `json:"mnemonic"          validate:"required,min=1"`
	Password        string `json:"password"`
	AccountId       uint32 `json:"account_id"        validate:"max=2147483647"`
	PaymentId       uint32 `json:"payment_id"        validate:"max=2147483647"`
	StakeId         uint32 `json:"stake_id"          validate:"max=2147483647"`
	DrepId          uint32 `json:"drep_id"           validate:"max=2147483647"`
	CommitteeColdId uint32 `json:"committee_cold_id" validate:"max=2147483647"`
	CommitteeHotId  uint32 `json:"committee_hot_id"  validate:"max=2147483647"`
	PoolColdId      uint32 `json:"pool_cold_id"      validate:"max=2147483647"`
	AddressId       uint32 `json:"address_id"        validate:"max=2147483647"`
}

// WalletUpdateRequest defines the request payload for wallet update
type WalletUpdateRequest struct {
	Name        string `json:"name"        validate:"required,min=1,max=100"`
	Password    string `json:"password"`
	Description string `json:"description" validate:"max=500"`
}

// ScriptCreateRequest defines the request payload for script creation
type ScriptCreateRequest struct {
	Type           string   `json:"type"                      validate:"required,oneof=nOf all any"`
	Required       int      `json:"required"                  validate:"omitempty,min=1"`
	KeyHashes      []string `json:"key_hashes"                validate:"required,min=1,dive,hexadecimal,len=56"`
	TimelockBefore uint64   `json:"timelock_before,omitempty"                                                   swaggertype:"integer" format:"int64"`
	TimelockAfter  uint64   `json:"timelock_after,omitempty"                                                    swaggertype:"integer" format:"int64"`
	Network        string   `json:"network"                   validate:"required,oneof=mainnet testnet"`
}

// ScriptValidateRequest defines the request payload for script validation
type ScriptValidateRequest struct {
	Script            map[string]any `json:"script"                       validate:"required"`
	Signatures        []string       `json:"signatures,omitempty"         validate:"dive,hexadecimal,len=128"`
	Slot              uint64         `json:"slot,omitempty"                                                   swaggertype:"integer" format:"int64"`
	RequireSignatures bool           `json:"require_signatures,omitempty"`
}

// ScriptAddressRequest defines the request payload for script address generation
type ScriptAddressRequest struct {
	Script  map[string]any `json:"script"  validate:"required"`
	Network string         `json:"network" validate:"required,oneof=mainnet testnet"`
}

// ScriptResponse defines the response payload for script operations
type ScriptResponse struct {
	Type       string         `json:"type"`
	Script     map[string]any `json:"script"`
	Address    string         `json:"address,omitempty"`
	ScriptHash string         `json:"scriptHash,omitempty"`
}

// ScriptValidateResponse defines the response payload for script validation
type ScriptValidateResponse struct {
	ScriptHash string `json:"scriptHash"`
	Signatures int    `json:"signatures"`
	Slot       uint64 `json:"slot"       swaggertype:"integer" format:"int64"`
	Valid      bool   `json:"valid"`
}

// ScriptAddressResponse defines the response payload for script address generation
type ScriptAddressResponse struct {
	Address    string `json:"address"`
	Network    string `json:"network"`
	ScriptHash string `json:"scriptHash"`
}

//	@title			bursa
//	@version		v0
//	@description	Programmable Cardano Wallet API
//	@Schemes		http
//	@BasePath		/

//	@contact.name	Blink Labs
//	@contact.url	https://blinklabs.io
//	@contact.email	support@blinklabs.io

//	@license.name	Apache 2.0
//	@license.url	http://www.apache.org/licenses/LICENSE-2.0.html

// Define Prometheus metrics
var (
	walletsCreatedCounter = prometheus.NewCounter(prometheus.CounterOpts{
		Name: "bursa_wallets_created_count",
		Help: "Total number of wallets created",
	})
	walletsDeletedCounter = prometheus.NewCounter(prometheus.CounterOpts{
		Name: "bursa_wallets_deleted_count",
		Help: "Total number of wallets deleted",
	})
	walletsFailCounter = prometheus.NewCounter(prometheus.CounterOpts{
		Name: "bursa_wallets_fail_count",
		Help: "Total number of wallet creation or restoration failures",
	})
	walletsRestoreCounter = prometheus.NewCounter(prometheus.CounterOpts{
		Name: "bursa_wallets_restore_count",
		Help: "Total number of wallets restored",
	})
	walletsUpdatedCounter = prometheus.NewCounter(prometheus.CounterOpts{
		Name: "bursa_wallets_updated_count",
		Help: "Total number of wallets updated",
	})
)

// Register Prometheus metrics
func init() {
	validate = validator.New()
	prometheus.MustRegister(walletsCreatedCounter)
	prometheus.MustRegister(walletsDeletedCounter)
	prometheus.MustRegister(walletsFailCounter)
	prometheus.MustRegister(walletsRestoreCounter)
	prometheus.MustRegister(walletsUpdatedCounter)
}

// Start initializes and starts the HTTP servers for the API and metrics
// Listeners can be passed in for testing purposes to provide ephermeral ports
func Start(
	ctx context.Context,
	cfg *config.Config,
	apiListener, metricsListener net.Listener,
) error {
	logger := logging.GetLogger()
	accessLogger := logging.GetAccessLogger()

	logger.Info("initializing API server")

	//
	// Main HTTP server for API endpoints
	//
	mainMux := http.NewServeMux()

	// Healthcheck
	mainMux.HandleFunc("/healthcheck", handleHealthcheck)

	// Prometheus endpoint
	mainMux.Handle("/metrics", promhttp.Handler())

	// Swagger endpoint
	mainMux.HandleFunc("/swagger/", httpSwagger.WrapHandler)

	// API routes
	mainMux.HandleFunc("/api/wallet/create", handleWalletCreate)
	mainMux.HandleFunc("/api/wallet/restore", handleWalletRestore)

	// Script routes
	mainMux.HandleFunc("/api/script/create", handleScriptCreate)
	mainMux.HandleFunc("/api/script/validate", handleScriptValidate)
	mainMux.HandleFunc("/api/script/address", handleScriptAddress)

	// GCP routes
	if cfg.Google.Project != "" && cfg.Google.ResourceId != "" {
		mainMux.HandleFunc("/api/wallet/list", handleWalletList)
		mainMux.HandleFunc("/api/wallet/get", handleWalletGet)
		mainMux.HandleFunc("/api/wallet/update", handleWalletUpdate)
		mainMux.HandleFunc("/api/wallet/delete", handleWalletDelete)
	}

	// Wrap the mainMux with an access-logging middleware
	mainHandler := logMiddleware(mainMux, accessLogger)

	//
	// Metrics HTTP server
	//
	metricsMux := http.NewServeMux()
	metricsMux.Handle("/metrics", promhttp.Handler())

	// Start metrics server
	go func() {
		logger.Info("starting metrics listener",
			"address", cfg.Metrics.ListenAddress,
			"port", cfg.Metrics.ListenPort,
		)
		var err error
		if metricsListener == nil {
			server := &http.Server{
				Addr: fmt.Sprintf(
					"%s:%d",
					cfg.Metrics.ListenAddress,
					cfg.Metrics.ListenPort,
				),
				Handler:           metricsMux,
				ReadHeaderTimeout: 60 * time.Second,
			}
			err = server.ListenAndServe()
		} else {
			server := &http.Server{
				Handler:           metricsMux,
				ReadHeaderTimeout: 60 * time.Second,
			}
			err = server.Serve(metricsListener)
		}
		if err != nil && err != http.ErrServerClosed {
			logger.Error("metrics listener failed to start", "error", err)
		}
	}()

	// Start API server
	logger.Info("starting API listener",
		"address", cfg.Api.ListenAddress,
		"port", cfg.Api.ListenPort,
	)
	var err error
	if apiListener == nil {
		server := &http.Server{
			Addr: fmt.Sprintf(
				"%s:%d",
				cfg.Api.ListenAddress,
				cfg.Api.ListenPort,
			),
			Handler:           mainHandler,
			ReadHeaderTimeout: 60 * time.Second,
		}
		err = server.ListenAndServe()
	} else {
		server := &http.Server{
			Handler:           mainHandler,
			ReadHeaderTimeout: 60 * time.Second,
		}
		err = server.Serve(apiListener)
	}
	return err
}

func logMiddleware(next http.Handler, accessLogger *slog.Logger) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		accessLogger.Info("request received",
			"method", r.Method,
			"path", r.URL.Path,
			"remote_addr", r.RemoteAddr,
		)

		// Wrap the ResponseWriter to capture status code
		rec := &statusRecorder{
			ResponseWriter: w,
			statusCode:     http.StatusOK,
		}
		next.ServeHTTP(rec, r)

		accessLogger.Info("response sent",
			"status", rec.statusCode,
			"method", r.Method,
			"path", r.URL.Path,
			"remote_addr", r.RemoteAddr,
		)
	})
}

// statusRecorder helps to record the response status code
type statusRecorder struct {
	http.ResponseWriter
	statusCode int
}

func (r *statusRecorder) WriteHeader(code int) {
	r.statusCode = code
	r.ResponseWriter.WriteHeader(code)
}

// handleHealthcheck responds to GET /healthcheck
func handleHealthcheck(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}
	w.Header().Set("Content-Type", "application/json")
	_, _ = w.Write([]byte(`{"healthy": true}`))
}

// handleWalletCreate godoc
//
//	@Summary		Create a wallet
//	@Description	Create a wallet and return details
//	@Produce		json
//	@Success		200	{object}	bursa.Wallet	"Ok"
//	@Router			/api/wallet/create [get]
func handleWalletCreate(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	cfg := config.GetConfig()
	logger := logging.GetLogger()

	mnemonic, err := bursa.GenerateMnemonic()
	if err != nil {
		logger.Error("failed to generate mnemonic", "error", err)
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = fmt.Fprintf(w, "failed to generate mnemonic: %s", err)
		walletsFailCounter.Inc()
		return
	}

	wallet, err := bursa.NewWallet(
		mnemonic,
		cfg.Network,
		"",
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
	)
	if err != nil {
		logger.Error("failed to initialize wallet", "error", err)
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = fmt.Fprintf(w,
			"failed to initialize wallet: %s", err)
		// Increment fail counter
		walletsFailCounter.Inc()
		return
	}

	// Persistence
	if cfg.Google.Project != "" && cfg.Google.ResourceId != "" {
		name := uuid.NewString()
		g := gcp.NewGoogleWallet(name)
		g.SetDescription("automatically generated at " + time.Now().String())
		if err := g.PopulateFrom(wallet); err != nil {
			logger.Error("failed to populate wallet", "error", err)
			w.WriteHeader(http.StatusInternalServerError)
			_, _ = fmt.Fprintf(w, "failed to populate wallet: %s", err)
			walletsFailCounter.Inc()
			return
		}
		if err := g.Save(r.Context()); err != nil {
			logger.Error("failed to save wallet", "error", err)
			w.WriteHeader(http.StatusInternalServerError)
			_, _ = fmt.Fprintf(w,
				"failed to save wallet: %s", err)
			// Increment fail counter
			walletsFailCounter.Inc()
			return
		}
	}

	w.Header().Set("Content-Type", "application/json")
	resp, err := json.Marshal(wallet)
	if err != nil {
		w.Header().Set("Content-Type", "application/json")
		logger.Error("failed to serialize google wallet", "error", err)
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = fmt.Fprintf(w,
			"failed to serialize google wallet: %s", err)
		walletsFailCounter.Inc()
		return
	}
	_, _ = w.Write(resp)
	// Increment creation counter
	walletsCreatedCounter.Inc()
}

// handleWalletRestore handles the wallet restoration request.
//
//	@Summary		Restore a wallet using a mnemonic seed phrase
//	@Description	Restores a wallet using the provided mnemonic seed phrase and optional password and returns wallet details.
//	@Accept			json
//	@Produce		json
//	@Param			request	body		WalletRestoreRequest	true	"Wallet Restore Request"
//	@Success		200		{object}	bursa.Wallet			"Wallet successfully restored"
//	@Failure		400		{object}	ErrorResponse			"Invalid request"
//	@Failure		500		{object}	ErrorResponse			"Internal server error"
//	@Router			/api/wallet/restore [post]
func handleWalletRestore(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req WalletRestoreRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		_, _ = w.Write([]byte(`{"error":"Invalid JSON request"}`))
		// Increment fail counter
		walletsFailCounter.Inc()
		return
	}

	// Validate the request
	if err := validate.Struct(req); err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		// Parse validator errors for cleaner response
		var validationErrors validator.ValidationErrors
		if errors.As(err, &validationErrors) {
			_, _ = fmt.Fprintf(
				w,
				`{"error":"Validation failed","fields":%s}`,
				formatValidationErrors(validationErrors),
			)
		} else {
			_, _ = w.Write([]byte(`{"error":"Invalid request format"}`))
		}
		walletsFailCounter.Inc()
		return
	}

	cfg := config.GetConfig()
	logger := logging.GetLogger()
	wallet, err := bursa.NewWallet(
		req.Mnemonic,
		cfg.Network,
		req.Password,
		req.AccountId,
		req.PaymentId,
		req.StakeId,
		req.DrepId,
		req.CommitteeColdId,
		req.CommitteeHotId,
		req.PoolColdId,
		req.AddressId,
	)
	if err != nil {
		// Check for client validation errors vs server errors
		if errors.Is(err, bursa.ErrInvalidMnemonic) ||
			errors.Is(err, bursa.ErrInvalidDerivationIndex) ||
			errors.Is(err, bursa.ErrInvalidNetwork) {
			writeJSONError(
				w,
				logger,
				map[string]string{"error": err.Error()},
				http.StatusBadRequest,
			)
		} else {
			logger.Error("failed to create wallet", "error", err)
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusInternalServerError)
			_, _ = w.Write([]byte(`{"error":"Internal server error"}`))
		}
		walletsFailCounter.Inc()
		return
	}

	// Persistence
	if cfg.Google.Project != "" && cfg.Google.ResourceId != "" {
		name := uuid.NewString()
		g := gcp.NewGoogleWallet(name)
		g.SetDescription("restored at " + time.Now().String())
		if err := g.PopulateFrom(wallet); err != nil {
			w.Header().Set("Content-Type", "application/json")
			logger.Error("failed to populate wallet", "error", err)
			w.WriteHeader(http.StatusInternalServerError)
			_, _ = fmt.Fprintf(w, "failed to populate wallet: %s", err)
			walletsFailCounter.Inc()
			return
		}
		if err := g.Save(r.Context()); err != nil {
			w.Header().Set("Content-Type", "application/json")
			logger.Error("failed to save wallet", "error", err)
			w.WriteHeader(http.StatusInternalServerError)
			_, _ = fmt.Fprintf(w,
				"failed to save wallet: %s", err)
			// Increment fail counter
			walletsFailCounter.Inc()
			return
		}
	}

	w.Header().Set("Content-Type", "application/json")
	resp, err := json.Marshal(wallet)
	if err != nil {
		logger.Error("failed to serialize google wallet", "error", err)
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = fmt.Fprintf(w,
			"failed to serialize google wallet: %s", err)
		walletsFailCounter.Inc()
		return
	}
	_, _ = w.Write(resp)
	// Increment restore counter
	walletsRestoreCounter.Inc()
}

// handleWalletList godoc
//
//	@Summary		Lists wallets
//	@Description	List all wallets stored in secret storage matching our prefix
//	@Produce		json
//	@Success		200	{object}	[]string	"Ok"
//	@Router			/api/wallet/list [get]
func handleWalletList(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	logger := logging.GetLogger()

	wallets, err := gcp.ListGoogleWallets(r.Context(), nil)
	if err != nil {
		logger.Error("failed to load google wallets", "error", err)
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = fmt.Fprintf(w,
			"failed to load google wallets: %s", err)
		walletsFailCounter.Inc()
		return
	}

	w.Header().Set("Content-Type", "application/json")
	resp, err := json.Marshal(wallets)
	if err != nil {
		logger.Error("failed to deserialize google wallets", "error", err)
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = fmt.Fprintf(w,

			"failed to deserialize google wallets: %s", err)
		walletsFailCounter.Inc()
		return
	}
	_, _ = w.Write(resp)
}

// handleWalletGet handles the wallet get request.
//
//	@Summary		Get wallet from persistent storage
//	@Description	Gets a wallet from persistent storage and optional password and returns wallet details.
//	@Accept			json
//	@Produce		json
//	@Param			request	body		WalletGetRequest	true	"Wallet Restore Request"
//	@Success		200		{object}	bursa.Wallet		"Wallet successfully loaded"
//	@Failure		400		{object}	ErrorResponse		"Invalid request"
//	@Failure		500		{object}	ErrorResponse		"Internal server error"
//	@Router			/api/wallet/get [post]
func handleWalletGet(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req WalletGetRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		_, _ = w.Write([]byte(`{"error":"Invalid JSON request"}`))
		// Increment fail counter
		walletsFailCounter.Inc()
		return
	}

	// Validate the request
	if err := validate.Struct(req); err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		// Parse validator errors for cleaner response
		var validationErrors validator.ValidationErrors
		if errors.As(err, &validationErrors) {
			_, _ = fmt.Fprintf(
				w,
				`{"error":"Validation failed","fields":%s}`,
				formatValidationErrors(validationErrors),
			)
		} else {
			_, _ = w.Write([]byte(`{"error":"Invalid request format"}`))
		}
		walletsFailCounter.Inc()
		return
	}

	logger := logging.GetLogger()

	// Load wallet from Google
	g := gcp.NewGoogleWallet(req.Name)
	if err := g.Load(r.Context()); err != nil {
		logger.Error(
			"failed to load google wallet",
			"error",
			err,
			"name",
			req.Name,
		)

		// Check GCP error codes for proper HTTP status mapping
		if grpcStatus, ok := status.FromError(err); ok {
			mapGRPCToHTTPError(w, grpcStatus)
		} else {
			// Non-gRPC error, treat as internal server error
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusInternalServerError)
			_, _ = w.Write([]byte(`{"error":"Internal server error"}`))
		}
		walletsFailCounter.Inc()
		return
	}

	// Populate bursa wallet
	wallet := &bursa.Wallet{}
	err := g.PopulateTo(wallet)
	if err != nil {
		w.Header().Set("Content-Type", "application/json")
		logger.Error("failed to convert google wallet", "error", err)
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = fmt.Fprintf(w,
			"failed to convert google wallet: %s", err)
		walletsFailCounter.Inc()
		return
	}

	w.Header().Set("Content-Type", "application/json")
	resp, err := json.Marshal(wallet)
	if err != nil {
		w.Header().Set("Content-Type", "application/json")
		logger.Error("failed to serialize google wallet", "error", err)
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = fmt.Fprintf(w,
			"failed to serialize google wallet: %s", err)
		walletsFailCounter.Inc()
		return
	}
	_, _ = w.Write(resp)
}

// handleWalletDelete handles the wallet delete request.
//
//	@Summary		Delete wallet from persistent storage
//	@Description	Deletes a wallet from persistent storage and optional password.
//	@Accept			json
//	@Produce		json
//	@Param			request	body		WalletDeleteRequest	true	"Wallet Delete Request"
//	@Success		200		{object}	string				"Wallet successfully deleted"
//	@Failure		400		{object}	ErrorResponse		"Invalid request"
//	@Failure		500		{object}	ErrorResponse		"Internal server error"
//	@Router			/api/wallet/delete [post]
func handleWalletDelete(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req WalletDeleteRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		_, _ = w.Write([]byte(`{"error":"Invalid JSON request"}`))
		// Increment fail counter
		walletsFailCounter.Inc()
		return
	}

	// Validate the request
	if err := validate.Struct(req); err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		// Parse validator errors for cleaner response
		var validationErrors validator.ValidationErrors
		if errors.As(err, &validationErrors) {
			_, _ = fmt.Fprintf(
				w,
				`{"error":"Validation failed","fields":%s}`,
				formatValidationErrors(validationErrors),
			)
		} else {
			_, _ = w.Write([]byte(`{"error":"Invalid request format"}`))
		}
		walletsFailCounter.Inc()
		return
	}

	logger := logging.GetLogger()

	// Load wallet from Google
	g := gcp.NewGoogleWallet(req.Name)
	if err := g.Delete(r.Context()); err != nil {
		logger.Error(
			"failed to delete google wallet",
			"error",
			err,
			"name",
			req.Name,
		)

		// Check GCP error codes for proper HTTP status mapping
		if grpcStatus, ok := status.FromError(err); ok {
			mapGRPCToHTTPError(w, grpcStatus)
		} else {
			// Non-gRPC error, treat as internal server error
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusInternalServerError)
			_, _ = w.Write([]byte(`{"error":"Internal server error"}`))
		}
		walletsFailCounter.Inc()
		return
	}

	w.Header().Set("Content-Type", "application/json")
	_, _ = w.Write([]byte("\"OK\""))
	// Increment delete counter
	walletsDeletedCounter.Inc()
}

// handleWalletUpdate handles the wallet update request.
//
//	@Summary		Update a wallet in persistent storage
//	@Description	Updates a wallet from persistent storage and optional password and returns wallet details.
//	@Accept			json
//	@Produce		json
//	@Param			request	body		WalletUpdateRequest	true	"Wallet Update Request"
//	@Success		200		{object}	string				"Wallet successfully updated"
//	@Failure		400		{string}	string				"Invalid request"
//	@Failure		500		{string}	string				"Internal server error"
//	@Router			/api/wallet/update [post]
func handleWalletUpdate(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req WalletUpdateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		_, _ = w.Write([]byte(`{"error":"Invalid JSON request"}`))
		// Increment fail counter
		walletsFailCounter.Inc()
		return
	}

	// Validate the request
	if err := validate.Struct(req); err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		// Parse validator errors for cleaner response
		var validationErrors validator.ValidationErrors
		if errors.As(err, &validationErrors) {
			_, _ = fmt.Fprintf(
				w,
				`{"error":"Validation failed","fields":%s}`,
				formatValidationErrors(validationErrors),
			)
		} else {
			_, _ = w.Write([]byte(`{"error":"Invalid request format"}`))
		}
		walletsFailCounter.Inc()
		return
	}

	logger := logging.GetLogger()

	// Load wallet from Google
	g := gcp.NewGoogleWallet(req.Name)
	if err := g.Load(r.Context()); err != nil {
		logger.Error(
			"failed to load google wallet",
			"error",
			err,
			"name",
			req.Name,
		)

		// Check GCP error codes for proper HTTP status mapping
		if grpcStatus, ok := status.FromError(err); ok {
			mapGRPCToHTTPError(w, grpcStatus)
		} else {
			// Non-gRPC error, treat as internal server error
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusInternalServerError)
			_, _ = w.Write([]byte(`{"error":"Internal server error"}`))
		}
		walletsFailCounter.Inc()
		return
	}

	if g.Description() != req.Description {
		g.SetDescription(req.Description)
		if err := g.Save(r.Context()); err != nil {
			w.Header().Set("Content-Type", "application/json")
			logger.Error("failed to save google wallet", "error", err)
			w.WriteHeader(http.StatusInternalServerError)
			_, _ = fmt.Fprintf(w,
				"failed to save google wallet: %s", err)
			walletsFailCounter.Inc()
			return
		}
		// Increment update counter
		walletsUpdatedCounter.Inc()
	}

	w.Header().Set("Content-Type", "application/json")
	_, _ = w.Write([]byte("\"OK\""))
}

// handleScriptCreate godoc
//
//	@Summary		Create a multi-signature script
//	@Description	Create a new multi-signature script with the specified parameters
//	@Accept			json
//	@Produce		json
//	@Param			request	body		ScriptCreateRequest	true	"Script Create Request"
//	@Success		200		{object}	ScriptResponse		"Script successfully created"
//	@Failure		400		{object}	ErrorResponse		"Invalid request"
//	@Failure		500		{object}	ErrorResponse		"Internal server error"
//	@Router			/api/script/create [post]
func handleScriptCreate(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req ScriptCreateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		_, _ = w.Write([]byte(`{"error":"Invalid JSON request"}`))
		return
	}

	// Validate the request
	if err := validate.Struct(req); err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		var validationErrors validator.ValidationErrors
		if errors.As(err, &validationErrors) {
			_, _ = fmt.Fprintf(
				w,
				`{"error":"Validation failed","fields":%s}`,
				formatValidationErrors(validationErrors),
			)
		} else {
			_, _ = w.Write([]byte(`{"error":"Invalid request format"}`))
		}
		return
	}

	logger := logging.GetLogger()

	// Parse key hashes
	hashes := make([][]byte, len(req.KeyHashes))
	for i, hashStr := range req.KeyHashes {
		hash, err := hex.DecodeString(hashStr)
		if err != nil {
			writeJSONError(w, logger, map[string]string{
				"error": "Invalid key hash format: " + hashStr,
			}, http.StatusBadRequest)
			return
		}
		hashes[i] = hash
	}

	// Create the script
	var script bursa.Script
	var err error
	switch req.Type {
	case "nOf":
		if req.Required <= 0 || req.Required > len(hashes) {
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write(
				[]byte(`{"error":"Invalid required signatures count"}`),
			)
			return
		}
		script, err = bursa.NewMultiSigScript(req.Required, hashes...)
	case "all":
		script, err = bursa.NewAllMultiSigScript(hashes...)
	case "any":
		script, err = bursa.NewAnyMultiSigScript(hashes...)
	default:
		writeJSONError(w, logger, map[string]string{
			"error": "Unsupported script type: " + req.Type,
		}, http.StatusBadRequest)
		return
	}
	if err != nil {
		logger.Error("failed to create script", "error", err)
		// Do not expose internal error details to clients. If the error is a
		// known validation error from the bursa package, return a concise
		// client-friendly message; otherwise return a generic message.
		// Don't expose internal error details to API clients.
		writeJSONError(
			w,
			logger,
			map[string]string{"error": "Failed to create script"},
			http.StatusBadRequest,
		)
		return
	}

	// Apply timelock if specified
	if req.TimelockBefore > 0 && req.TimelockAfter > 0 {
		writeJSONError(w, logger, map[string]string{
			"error": "cannot specify both timelock_before and timelock_after",
		}, http.StatusBadRequest)
		return
	}
	if req.TimelockBefore > 0 {
		script, err = bursa.NewTimelockedScript(
			req.TimelockBefore,
			true,
			script,
		)
		if err != nil {
			logger.Error("failed to create timelocked script", "error", err)
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write(
				[]byte(`{"error":"Failed to create timelocked script"}`),
			)
			return
		}
	} else if req.TimelockAfter > 0 {
		script, err = bursa.NewTimelockedScript(req.TimelockAfter, false, script)
		if err != nil {
			logger.Error("failed to create timelocked script", "error", err)
			w.Header().Set("Content-Type", "application/json")
			w.WriteHeader(http.StatusBadRequest)
			_, _ = w.Write([]byte(`{"error":"Failed to create timelocked script"}`))
			return
		}
	}

	// Marshal script data
	scriptData, err := bursa.MarshalScript(script, req.Network)
	if err != nil {
		logger.Error("failed to marshal script", "error", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = w.Write([]byte(`{"error":"Internal server error"}`))
		return
	}

	// Return ScriptResponse with consistent field naming
	response := ScriptResponse{
		Type:       scriptData.Type,
		Script:     scriptData.Script,
		Address:    scriptData.Address,
		ScriptHash: scriptData.Hash,
	}

	w.Header().Set("Content-Type", "application/json")
	resp, err := json.Marshal(response)
	if err != nil {
		logger.Error("failed to serialize script response", "error", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = w.Write([]byte(`{"error":"Internal server error"}`))
		return
	}
	_, _ = w.Write(resp)
}

// handleScriptValidate godoc
//
//	@Summary		Validate a script
//	@Description	Validate a script's structure and requirements
//	@Accept			json
//	@Produce		json
//	@Param			request	body		ScriptValidateRequest	true	"Script Validate Request"
//	@Success		200		{object}	ScriptValidateResponse	"Script validation result"
//	@Failure		400		{object}	ErrorResponse			"Invalid request"
//	@Failure		500		{object}	ErrorResponse			"Internal server error"
//	@Router			/api/script/validate [post]
func handleScriptValidate(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req ScriptValidateRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		_, _ = w.Write([]byte(`{"error":"Invalid JSON request"}`))
		return
	}

	// Validate the request
	if err := validate.Struct(req); err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		var validationErrors validator.ValidationErrors
		if errors.As(err, &validationErrors) {
			_, _ = fmt.Fprintf(
				w,
				`{"error":"Validation failed","fields":%s}`,
				formatValidationErrors(validationErrors),
			)
		} else {
			_, _ = w.Write([]byte(`{"error":"Invalid request format"}`))
		}
		return
	}

	logger := logging.GetLogger()

	// Unmarshal the script
	script, err := bursa.UnmarshalScript(&bursa.ScriptData{
		Type:   "NativeScript",
		Script: req.Script,
	})
	if err != nil {
		logger.Error("failed to unmarshal script", "error", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		_, _ = w.Write([]byte(`{"error":"Invalid script format"}`))
		return
	}

	// Parse signatures if provided
	var signatures [][]byte
	if len(req.Signatures) > 0 {
		signatures = make([][]byte, len(req.Signatures))
		for i, sigStr := range req.Signatures {
			sig, err := hex.DecodeString(sigStr)
			if err != nil {
				logger.Error(
					"invalid signature format",
					"signature",
					sigStr,
					"error",
					err,
				)
				w.Header().Set("Content-Type", "application/json")
				w.WriteHeader(http.StatusBadRequest)
				_, _ = w.Write([]byte(`{"error":"Invalid signature format"}`))
				return
			}
			signatures[i] = sig
		}
	}

	// Validate the script
	valid := bursa.ValidateScript(
		script,
		signatures,
		req.Slot,
		req.RequireSignatures,
	)
	hash, err := bursa.GetScriptHash(script)
	if err != nil {
		logger.Error("failed to get script hash", "error", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = w.Write([]byte(`{"error":"Internal server error"}`))
		return
	}

	response := ScriptValidateResponse{
		ScriptHash: hex.EncodeToString(hash),
		Signatures: len(signatures),
		Slot:       req.Slot,
		Valid:      valid,
	}

	w.Header().Set("Content-Type", "application/json")
	resp, err := json.Marshal(response)
	if err != nil {
		logger.Error("failed to serialize validation response", "error", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = w.Write([]byte(`{"error":"Internal server error"}`))
		return
	}
	_, _ = w.Write(resp)
}

// handleScriptAddress godoc
//
//	@Summary		Generate script address
//	@Description	Generate an address for a script on the specified network
//	@Accept			json
//	@Produce		json
//	@Param			request	body		ScriptAddressRequest	true	"Script Address Request"
//	@Success		200		{object}	ScriptAddressResponse	"Script address generated"
//	@Failure		400		{object}	ErrorResponse			"Invalid request"
//	@Failure		500		{object}	ErrorResponse			"Internal server error"
//	@Router			/api/script/address [post]
func handleScriptAddress(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req ScriptAddressRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		_, _ = w.Write([]byte(`{"error":"Invalid JSON request"}`))
		return
	}

	// Validate the request
	if err := validate.Struct(req); err != nil {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		var validationErrors validator.ValidationErrors
		if errors.As(err, &validationErrors) {
			_, _ = fmt.Fprintf(
				w,
				`{"error":"Validation failed","fields":%s}`,
				formatValidationErrors(validationErrors),
			)
		} else {
			_, _ = w.Write([]byte(`{"error":"Invalid request format"}`))
		}
		return
	}

	logger := logging.GetLogger()

	// Unmarshal the script
	script, err := bursa.UnmarshalScript(&bursa.ScriptData{
		Type:   "NativeScript",
		Script: req.Script,
	})
	if err != nil {
		logger.Error("failed to unmarshal script", "error", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		_, _ = w.Write([]byte(`{"error":"Invalid script format"}`))
		return
	}

	// Generate address
	address, err := bursa.GetScriptAddress(script, req.Network)
	if err != nil {
		logger.Error("failed to generate script address", "error", err)
		// If the error is a known client error, return its message; otherwise
		// return a generic message to avoid leaking internal details.
		if errors.Is(err, bursa.ErrInvalidNetwork) {
			writeJSONError(
				w,
				logger,
				map[string]string{"error": "Invalid network"},
				http.StatusBadRequest,
			)
		} else {
			writeJSONError(w, logger, map[string]string{"error": "Failed to generate script address"}, http.StatusInternalServerError)
		}
		return
	}

	hash, err := bursa.GetScriptHash(script)
	if err != nil {
		logger.Error("failed to get script hash", "error", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = w.Write([]byte(`{"error":"Internal server error"}`))
		return
	}

	response := ScriptAddressResponse{
		Address:    address,
		Network:    req.Network,
		ScriptHash: hex.EncodeToString(hash),
	}

	w.Header().Set("Content-Type", "application/json")
	resp, err := json.Marshal(response)
	if err != nil {
		logger.Error("failed to serialize address response", "error", err)
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusInternalServerError)
		_, _ = w.Write([]byte(`{"error":"Internal server error"}`))
		return
	}
	_, _ = w.Write(resp)
}
